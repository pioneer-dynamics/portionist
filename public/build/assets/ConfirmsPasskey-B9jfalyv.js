import{d as y,T as C,Q as g,o as P,e as I,f as T}from"./app-BxVXrtEs.js";function v(e){return new TextEncoder().encode(e)}function p(e){const n=new Uint8Array(e);let t="";for(const a of n)t+=String.fromCharCode(a);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function b(e){const n=e.replace(/-/g,"+").replace(/_/g,"/"),t=(4-n.length%4)%4,r=n.padEnd(n.length+t,"="),a=atob(r),i=new ArrayBuffer(a.length),o=new Uint8Array(i);for(let c=0;c<a.length;c++)o[c]=a.charCodeAt(c);return i}function w(){return(window==null?void 0:window.PublicKeyCredential)!==void 0&&typeof window.PublicKeyCredential=="function"}function E(e){const{id:n}=e;return{...e,id:b(n),transports:e.transports}}function A(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class s extends Error{constructor({message:n,code:t,cause:r,name:a}){super(n,{cause:r}),this.name=a??r.name,this.code=t}}function D({error:e,options:n}){var r,a;const{publicKey:t}=n;if(!t)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(n.signal instanceof AbortSignal)return new s({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(((r=t.authenticatorSelection)==null?void 0:r.requireResidentKey)===!0)return new s({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(((a=t.authenticatorSelection)==null?void 0:a.userVerification)==="required")return new s({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new s({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new s({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return t.pubKeyCredParams.filter(o=>o.type==="public-key").length===0?new s({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new s({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const i=window.location.hostname;if(A(i)){if(t.rp.id!==i)return new s({message:`The RP ID "${t.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new s({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(t.user.id.byteLength<1||t.user.id.byteLength>64)return new s({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new s({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class O{createNewAbortSignal(){if(this.controller){const t=new Error("Cancelling existing WebAuthn API call for new one");t.name="AbortError",this.controller.abort(t)}const n=new AbortController;return this.controller=n,n.signal}cancelCeremony(){if(this.controller){const n=new Error("Manually cancelling existing WebAuthn API call");n.name="AbortError",this.controller.abort(n),this.controller=void 0}}}const _=new O,K=["cross-platform","platform"];function S(e){if(e&&!(K.indexOf(e)<0))return e}async function H(e){var f;if(!w())throw new Error("WebAuthn is not supported in this browser");const t={publicKey:{...e,challenge:b(e.challenge),user:{...e.user,id:v(e.user.id)},excludeCredentials:(f=e.excludeCredentials)==null?void 0:f.map(E)}};t.signal=_.createNewAbortSignal();let r;try{r=await navigator.credentials.create(t)}catch(u){throw D({error:u,options:t})}if(!r)throw new Error("Registration was not completed");const{id:a,rawId:i,response:o,type:c}=r;let d;typeof o.getTransports=="function"&&(d=o.getTransports());let m;if(typeof o.getPublicKeyAlgorithm=="function")try{m=o.getPublicKeyAlgorithm()}catch(u){R("getPublicKeyAlgorithm()",u)}let h;if(typeof o.getPublicKey=="function")try{const u=o.getPublicKey();u!==null&&(h=p(u))}catch(u){R("getPublicKey()",u)}let l;if(typeof o.getAuthenticatorData=="function")try{l=p(o.getAuthenticatorData())}catch(u){R("getAuthenticatorData()",u)}return{id:a,rawId:p(i),response:{attestationObject:p(o.attestationObject),clientDataJSON:p(o.clientDataJSON),transports:d,publicKeyAlgorithm:m,publicKey:h,authenticatorData:l},type:c,clientExtensionResults:r.getClientExtensionResults(),authenticatorAttachment:S(r.authenticatorAttachment)}}function R(e,n){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,n)}function N(e){return new TextDecoder("utf-8").decode(e)}function U(){const e=window.PublicKeyCredential;return e.isConditionalMediationAvailable===void 0?new Promise(n=>n(!1)):e.isConditionalMediationAvailable()}function k({error:e,options:n}){const{publicKey:t}=n;if(!t)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(n.signal instanceof AbortSignal)return new s({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new s({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const r=window.location.hostname;if(A(r)){if(t.rpId!==r)return new s({message:`The RP ID "${t.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new s({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new s({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function L(e,n=!1){var l,f;if(!w())throw new Error("WebAuthn is not supported in this browser");let t;((l=e.allowCredentials)==null?void 0:l.length)!==0&&(t=(f=e.allowCredentials)==null?void 0:f.map(E));const r={...e,challenge:b(e.challenge),allowCredentials:t},a={};if(n){if(!await U())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');a.mediation="conditional",r.allowCredentials=[]}a.publicKey=r,a.signal=_.createNewAbortSignal();let i;try{i=await navigator.credentials.get(a)}catch(u){throw k({error:u,options:a})}if(!i)throw new Error("Authentication was not completed");const{id:o,rawId:c,response:d,type:m}=i;let h;return d.userHandle&&(h=N(d.userHandle)),{id:o,rawId:p(c),response:{authenticatorData:p(d.authenticatorData),clientDataJSON:p(d.clientDataJSON),signature:p(d.signature),userHandle:h},type:m,clientExtensionResults:i.getClientExtensionResults(),authenticatorAttachment:S(i.authenticatorAttachment)}}const x={key:0},M={__name:"ConfirmsPasskey",props:{remember:{type:Boolean,default:!1},title:{type:String,default:"Confirm Passkey"},content:{type:String,default:"For your security, please confirm your passkey to continue."},email:{type:String,default:""},mode:{type:String,default:"verify",validate:e=>["login","verify"].indexOf(e)!==-1}},emits:["confirmed","cancelled"],setup(e,{expose:n,emit:t}){const r=t,a=y(!1),i=y(null),o=e,c=C({passkey:"",email:o.email,remember:!1}),d=(l=!1)=>{r("cancelled",l),a.value=!1},m=()=>{L(JSON.parse(JSON.stringify(g().props.jetstream.flash.options))).then(l=>{c.passkey=l,c.transform(f=>({...f,remember:o.remember?"on":""})).post(route(o.mode=="login"?"passkeys.login":"passkeys.verify"),{preserveScroll:!0,preserveState:!0,onSuccess:()=>{(o.mode=="login"||g().props.jetstream.flash.verified)&&(i.value=!0,h())},onError:f=>{console.error(f),i.value=!1,d()}})}).catch(l=>{console.log(l),d(),i.value=!1})};n({passkeyForm:c,start:(l=null)=>{w()||r("cancelled"),l&&(c.email=l),c.post(route("passkeys.authentication-options"),{preserveScroll:!0,preserveState:!0,onSuccess:()=>{g().props.jetstream.flash.options?(i.value=null,a.value=!0,m()):r("cancelled")},onError:f=>{d(!0)}})}});const h=()=>{a.value=!1,r("confirmed")};return(l,f)=>a.value?(P(),I("span",x)):T("",!0)}};export{M as _,H as s};
